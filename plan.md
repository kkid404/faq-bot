* FastAPI (core + потом микросервисы),
* React
* Docker + docker-compose,
* Postgres.

---

## -1. Контекст и фокус

* Делает один человек (Python + JS), без команды.
* Фокус ближайших 4–6 недель — демо через лендинг + чат для РФ (дальше — Израиль).
* Основные версии:
  * v0.1 — живой backend API с демо-логикой бота.
  * v0.2 — лендинг + демо-чат, подключенный к API.
  * v0.3 — минимальный личный кабинет владельца.
* Осознанно НЕ делаем в первых версиях:
  * Telegram-бот и `/bot-gateway-service`.
  * Платежи и подписки.
  * Сложные микросервисы и инфраструктуру, кроме того, что нужно для демо.

## 0. Как пользоваться этим планом

* Держи его как **backlog**: сверху — ближайшие шаги, ниже — более дальние.
* Каждый “блок” = маленький релиз (v0.1, v0.2 и т.д.).
* В начале каждой сессии работы:
  1. открыл план;
  2. выбрал один-двa пункта;
  3. сделал → поставил галочку.

## Блок 1. Базовый каркас проекта

**Цель:** всё разворачивается, FastAPI живой, ленд можно будет прикрутить.

**Задачи:**

* [X] Создать git-репозиторий с такой структурой папок (микросервисы):

  * `/core` – бизнес-логика, API
  * `/ai` – позже, для LLM
  * `/gateway` – позже, под телегу/ватсап
  * `/landing` – фронт с лендингом и демо-чатом
  * На первых версиях фактически реализуются только `/core` и `/landing`, остальные папки остаются заготовками до Блоков 6–7.

* [X] В `/core`:

  * [X] Инициализировать FastAPI-проект
  * [X] Добавить `main.py` с `/health`
  * [X] Настроить `uvicorn` для локального запуска

* [X] В корне проекта:

  * [X] Написать `docker-compose.yml` с:

    * `core`
    * `db` (Postgres)
  * [X] Убедиться, что `core` может подключиться к БД (хотя бы просто коннект).

**Готово, когда:**

* `docker-compose up` поднимает `core` и `db`.
* Запрос `GET /health` возвращает 200.
* `core` один раз успешно коннектится к БД.

---

## Блок 2. API для демо-чата (без фронта, только бек)

**Цель:** есть один эндпоинт, который уже “ведёт диалог” с демо-бизнесом (салон красоты).

**Задачи (в core):**

* [Х] Описать Pydantic-схемы:

  * [Х] `DemoMessageRequest { session_id: str, text: str }`
  * [Х] `DemoMessageResponse { reply_text: str }`

* [Х] Добавить файл с логикой демо, типа `demo_logic.py`:

  * [Х] Завести "интенты" (цена, запись, адрес, график, услуги) с наборами ключевых слов и фраз.
  * [Х] По входящему тексту находить подходящий интент по простому скорингу (кол-во совпавших ключевых слов).
  * [Х] Для каждого интента возвращать шаблон ответа, подставляя данные демо-бизнеса.
  * [Х] Если интент не найден, вежливо просить уточнить вопрос или предлагать основные варианты ("узнать цену", "записаться", "уточнить адрес").

* [Х] Добавить эндпоинт:

  * [Х] `POST /demo/message` → принимает `DemoMessageRequest`, возвращает `DemoMessageResponse`

* [Х] Проверить через `/docs`:

  * [Х] Отправить несколько тестовых сообщений
  * [Х] Посмотреть, как меняются ответы

> После этого у тебя есть настоящий API, к которому можно прикрутить фронт-чат.

**Готово, когда:**

* Эндпоинт `POST /demo/message` доступен и работает через `/docs`.
* На вопросы про цену, запись и адрес бот даёт ответы, похожие на живого сотрудника салона.
* Для непонятных вопросов бот вежливо просит уточнить или предлагает основные варианты ("узнать цену", "записаться", "уточнить адрес").

---

## Блок 3. Ленд + демо-чат на фронте

**Цель:** у тебя красивый (или хотя бы живой) лендинг с чатиком, который ходит в `/demo/message`.

**Задачи (в /landing):**

* [ ] Инициализировать фронт-проект (Next.js/React, что удобнее).

* [ ] Сделать простую страницу `index` с базовой структурой:

  * [ ] **Hero-блок**:

    * Заголовок вида:

      > “FAQ-бот для малого бизнеса, который отвечает клиентам и собирает заявки 24/7”
    * Краткое описание (1–2 предложения)
    * Кнопка “Попробовать демо” (скроллит к чату)

  * [ ] **Блок “Как это работает”** (3 шага)

    1. Владелец заполняет данные бизнеса
    2. Бот отвечает на вопросы вместо него
    3. Бот собирает заявки и отправляет админу

  * [ ] **Блок с демо-чатом**:

    * Компонент `<DemoChat />`, который:

      * [ ] хранит массив сообщений `{ from: 'user' | 'bot', text }`
      * [ ] рендерит пузырьки
      * [ ] по Enter/кнопке отправляет запрос `POST /demo/message`
      * [ ] показывает “бот печатает…” при ожидании ответа

  * [ ] **Форма захвата**:

    * поле email/телеги
    * кнопка “Хочу в пилот”

* [ ] Настроить CORS на бекенде, чтобы фронт мог ходить к API.

> После этого у тебя есть **видимый продукт**, который можно показывать людям.

**Готово, когда:**

* Лендинг открывается на десктопе и телефоне без ошибок.
* Чат на странице реально ходит в `POST /demo/message`.
* Данные из формы захвата хотя бы логируются на бэке (даже если пока без отдельной таблицы).

---

## Блок 4. От демо к реальной модели данных

**Цель:** вместо захардкоженного салона — реальные сущности в БД.

**Задачи (core-service + db):**

* [ ] Проектировать минимальную схему БД:

  * [ ] `users` (твои клиенты-владельцы):

    * id
    * email
    * hashed_password (или позже auth по ссылкам/телеге)

  * [ ] `businesses`:

    * id
    * owner_id
    * name
    * description
    * address
    * schedule
    * services (можно текстовым JSON/строкой на старте)

  * [ ] `leads`:

    * id
    * business_id
    * name
    * contact (телега/телефон/email)
    * message (чего хочет)
    * created_at

* [ ] Настроить миграции (Alembic или что тебе привычно).

* [ ] В `demo_logic` вместо жёсткого объекта:

  * [ ] Получать `business` из БД по id (для демо можно всегда брать id=1).

* [ ] Засидировать одну демо-запись бизнеса (салон “Луна”) в БД:

  * [ ] либо через миграцию,
  * [ ] либо вручную скриптом.

* [ ] Обновить `/demo/message`, чтобы он:

  * [ ] передавал `business_id` (для демо можно хардкодить 1),
  * [ ] использовал реальные данные `business` в ответах.

---

## Блок 5. Личный кабинет владельца (минимальный)

**Цель:** чтобы владелец бизнеса мог сам менять инфу, а не через код.

**Задачи:**

**Бек (core-service):**

* [ ] Добавить простой auth:

  * [ ] регистрация по email+паролю или просто “login link” по email
  * [ ] выдача JWT/сессии

* [ ] CRUD для бизнеса:

  * [ ] `GET /me/business`
  * [ ] `POST /me/business` (создать/обновить основные данные)

* [ ] Эндпоинт для лидов:

  * [ ] `GET /me/leads` — посмотреть заявки

**Фронт (/landing превращается ещё и в /app):**

* [ ] Страница входа/регистрации
* [ ] Страница “Мой бизнес” с формами:

  * name, description, address, schedule, services
* [ ] Страница “Заявки” — список лидов

> На этом этапе у тебя уже **реальный SaaS-скелет**: юзер логинится, настраивает бизнес, получает заявки.

---

## Блок 6. AI-ответы и ai-service

**Цель:** чтобы ответы были не только по правилам/if-ам, но и через LLM, и чтобы это жило в отдельном сервисе. При этом базовые сценарии по интентам остаются основой, а LLM используется как фолбэк.

**Шаг 1 — сначала просто интеграция LLM в core-service**

* [ ] Сделать функцию `generate_ai_reply(question, business_data)`:

  * [ ] промпт: “Ты бот салона красоты… вот данные бизнеса… ответь на вопрос клиента максимально конкретно”
  * [ ] вызов внешнего LLM API
  * [ ] защита от галлюцинаций (строго опираться на данные)

* [ ] В `process_message`:

  * [ ] сначала определяется интент и мы пытаемся ответить по сценариям (`demo_logic`).
  * [ ] если хороший интент не найден → звать `generate_ai_reply` как фолбэк.

**Шаг 2 — вынести в отдельный `ai-service`**

* [ ] Создать `/ai-service` (FastAPI):

  * [ ] эндпоинт `POST /generate-reply`:

    * вход: `{ question, business }`
    * выход: `{ reply_text }`

* [ ] Переписать `generate_ai_reply` в core-service, чтобы:

  * [ ] ходил HTTP-запросом к `http://ai-service:8000/generate-reply`

* [ ] Обновить `docker-compose.yml`, добавить `ai-service`.

---

## Блок 7. Bot-gateway-service и Telegram

**Цель:** тот же самый core, но теперь не только с ленда, а ещё и как реальный бот.

**Задачи:**

* [ ] Создать `/bot-gateway-service` (FastAPI).

* [ ] Написать роут:

  * [ ] `POST /webhook/telegram/{business_id}`:

    * парсит апдейт от Telegram
    * преобразует в unified-message `{ channel, channel_user_id, text, business_id }`
    * шлёт это в `core-service:/internal/handle-message`
    * отправляет ответ обратно в Telegram `sendMessage`

* [ ] В core-service:

  * [ ] добавить эндпоинт `/internal/handle-message` (как обсуждали раньше).

* [ ] Настроить webhook у бота через BotFather на `https://твойдомен/webhook/telegram/{business_id}`.

> Теперь у тебя: ленд + демо-чат + рабочий Telegram-бот, который использует один и тот же бек.

---

## Блок 8. Оплата и подписки (минимум)

**Цель:** не просто проект, а SaaS.

**Задачи:**

* [ ] Выбрать платёжку (Stripe/ЮKassa/др. – зависит от гео).

* [ ] Сделать сущность `plans` (tariff/подписка).

* [ ] Привязать `business` к плану:

  * лимит сообщений или заявок
  * или просто “free / pro”

* [ ] В dashboard:

  * [ ] страница “Тарифы”
  * [ ] кнопка “Оформить подписку” -> платёжный провайдер

* [ ] На бэке:

  * [ ] webhooks от платёжки, обновление статуса подписки

---

## Блок 9. Полировка, логирование, метрики

**Цель:** не страдать от дебага и понимать, жив ли продукт.

* [ ] Добавить нормальные логи в core-service и bot-gateway-service.

* [ ] Логировать:

  * ошибки
  * ключевые события (новый лид, запрос к ai-service, падения)

* [ ] Добавить простую метрику:

  * кол-во сообщений в день, кол-во лидов
  * можно писать в отдельную таблицу / Prometheus / даже просто в логи

---

## Блок “Парковка идей” (чтобы не потерять в процессе)

Сюда выписывай всё, что приходит в голову, но не срочно:

* [ ] Поддержка WhatsApp через отдельный адаптер.
* [ ] Автогенерация FAQ из сайта/Инсты бизнеса.
* [ ] Импорт/экспорт лидов (CSV).
* [ ] Роль “менеджера” у бизнеса (несколько пользователей на один бизнес).
* [ ] Локализация интерфейса (RU/EN).
* [ ] Несколько демо-сценариев на лендинге (например, салон / клиника / онлайн-школа) с переключателем.
* [ ] Сделать демо-диалог более живым: доработать тексты ответов, добавить дополнительные интенты под частые вопросы.

---

Если хочешь, следующим шагом можем:

